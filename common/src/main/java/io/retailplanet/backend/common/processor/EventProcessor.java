package io.retailplanet.backend.common.processor;

import org.jetbrains.annotations.NotNull;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.*;
import javax.lang.model.type.MirroredTypeException;
import javax.lang.model.util.ElementFilter;
import javax.tools.StandardLocation;
import java.io.*;
import java.net.URI;
import java.nio.file.Files;
import java.util.*;
import java.util.function.Supplier;

/**
 * Generates application.properties
 *
 * @author w.glanzer, 19.06.2019
 */
@SupportedAnnotationTypes({"io.retailplanet.backend.common.processor.IncomingEvent",
                           "io.retailplanet.backend.common.processor.OutgoingEvent",
                           "io.retailplanet.backend.common.processor.EventContainer"})
@SupportedSourceVersion(SourceVersion.RELEASE_6)
public class EventProcessor extends AbstractProcessor
{

  public EventProcessor()
  {
  }

  @Override
  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)
  {
    if (roundEnv.processingOver() || annotations.isEmpty())
      return false;

    _EventContainer container = null;
    List<_IncomingEvent> incomingEvents = new ArrayList<>();
    List<_OutgoingEvent> outgoingEvents = new ArrayList<>();
    for (TypeElement annotation : annotations)
    {
      for (Element element : roundEnv.getElementsAnnotatedWith(annotation))
      {
        switch (annotation.getQualifiedName().toString())
        {
          case "io.retailplanet.backend.common.processor.IncomingEvent":
            incomingEvents.add(new _IncomingEvent(element));
            break;

          case "io.retailplanet.backend.common.processor.OutgoingEvent":
            outgoingEvents.add(new _OutgoingEvent(element));
            break;

          case "io.retailplanet.backend.common.processor.EventContainer":
            container = new _EventContainer(element);
            break;
        }
      }
    }

    if (container == null)
      throw new RuntimeException("Missing EventContainer");

    // add defaults
    incomingEvents.addAll(_createDefaultIncomingEvents());
    outgoingEvents.addAll(_createDefaultOutgoingEvents());

    // Translate to application.properties content
    Map<String, String> content = _toFileContent(container, incomingEvents, outgoingEvents);

    // Write
    _writeToApplicationProperties(content);

    return true;
  }

  /**
   * @return all default incoming events
   */
  @NotNull
  private List<_IncomingEvent> _createDefaultIncomingEvents()
  {
    return Collections.singletonList(new _IncomingEvent("ERRORS_IN", "ERRORS", "latest", "io.retailplanet.backend.common.events.EventDeserializer"));
  }

  /**
   * @return all default outgoing events
   */
  @NotNull
  private List<_OutgoingEvent> _createDefaultOutgoingEvents()
  {
    return Collections.singletonList(new _OutgoingEvent("ERRORS_OUT", "ERRORS", "io.retailplanet.backend.common.events.EventSerializer"));
  }

  /**
   * Writes all given contents to the application.properties file
   *
   * @param pContent Content
   */
  private void _writeToApplicationProperties(@NotNull Map<String, String> pContent)
  {
    try
    {
      try (Writer writer = processingEnv.getFiler().createResource(StandardLocation.CLASS_OUTPUT, "", "application.properties").openWriter())
      {
        writer.append(_getApplicationPropertiesContent())
            .append('\n')
            .append("# Autogenerated by io.retailplanet.backend.common.processor.EventProcessor")
            .append('\n');
        for (Map.Entry<String, String> entry : pContent.entrySet())
          writer.append(entry.getKey())
              .append("=")
              .append(entry.getValue())
              .append("\n");
      }
    }
    catch (IOException e)
    {
      throw new RuntimeException(e);
    }
  }

  /**
   * @return The source content of application.properties
   */
  @NotNull
  private String _getApplicationPropertiesContent() throws IOException
  {
    URI targetFolderUri = processingEnv.getFiler().getResource(StandardLocation.CLASS_OUTPUT, "", "nothing").toUri();
    File moduleFolder = new File(targetFolderUri).getParentFile().getParentFile().getParentFile();
    File propertiesFile = new File(moduleFolder, "src/main/resources/application.properties");
    if(!propertiesFile.exists())
      return "";
    return String.join("\n", Files.readAllLines(propertiesFile.toPath()));
  }

  /**
   * Transforms the annotationprocessing elements to a readable map
   *
   * @param pContainer      Eventcontainer
   * @param pIncomingEvents all incoming events
   * @param pOutgoingEvents all outgoing events
   * @return a map for application.properties
   */
  @NotNull
  private Map<String, String> _toFileContent(@NotNull _EventContainer pContainer, @NotNull List<_IncomingEvent> pIncomingEvents,
                                             @NotNull List<_OutgoingEvent> pOutgoingEvents)
  {
    Map<String, String> defaultValues = new HashMap<>(pContainer.defaultValues);
    defaultValues.put("connector", "smallrye-kafka");
    defaultValues.put("bootstrap.servers", "${KAFKA_SERVERS}");

    Map<String, String> map = new LinkedHashMap<>();
    map.put("retailplanet.service.group.id", pContainer.groupID);

    // Jaeger defaults
    map.put("quarkus.jaeger.service-name", pContainer.groupID);
    map.put("quarkus.jaeger.sampler-type", "const");
    map.put("quarkus.jaeger.sampler-param", "1");
    map.put("quarkus.jaeger.endpoint", "${OPENTRACING_SERVERS:localhost}");
    map.put("mp.opentracing.server.operation-name-provider", "http-path");

    pIncomingEvents.forEach(pEv -> map.putAll(pEv.toMap(pContainer.groupID, defaultValues)));
    pOutgoingEvents.forEach(pEv -> map.putAll(pEv.toMap(defaultValues)));
    return map;
  }

  private static class _EventContainer
  {
    private final String groupID;
    private final Map<String, String> defaultValues = new HashMap<>();

    private _EventContainer(Element pElement)
    {
      EventContainer anno = pElement.getAnnotation(EventContainer.class);
      groupID = anno.groupID() + "_${KAFKA_GROUP_ID:dev}";
      String[] defaults = anno.defaults();
      for (int i = 0; i < defaults.length; i = i + 2)
        defaultValues.put(defaults[i], defaults[i + 1]);
    }
  }

  private static class _IncomingEvent
  {
    private static final String _IN_SUFFIX = "_IN";
    private final String name;
    private final String topic;
    private final String autoOffsetReset;
    private final String valueDeserializer;

    public _IncomingEvent(String pName, String pTopic, String pAutoOffsetReset, String pValueDeserializer)
    {
      name = pName;
      topic = pTopic;
      autoOffsetReset = pAutoOffsetReset;
      valueDeserializer = pValueDeserializer;
    }

    private _IncomingEvent(Element pElement)
    {
      name = ElementFilter.fieldsIn(Collections.singletonList(pElement)).get(0).getConstantValue().toString();
      if (!name.endsWith(_IN_SUFFIX))
        throw new RuntimeException(name + " is not a valid INCOMINGEVENT name");

      topic = name.substring(0, name.length() - _IN_SUFFIX.length());

      IncomingEvent event = pElement.getAnnotation(IncomingEvent.class);
      autoOffsetReset = event.autoOffsetReset();
      valueDeserializer = _getClassName(event::valueDeserializer);
    }

    @NotNull
    private Map<String, String> toMap(@NotNull String pGroupID, @NotNull Map<String, String> pDefaultValues)
    {
      String keyPrefix = "mp.messaging.incoming." + name.replace('.', '-') + ".";
      Map<String, String> result = new HashMap<>();

      // Add defaults
      pDefaultValues.forEach((pKey, pValue) -> result.put(keyPrefix + pKey, pValue));

      // Add all our values
      result.put(keyPrefix + "topic", topic);
      result.put(keyPrefix + "group.id", pGroupID);
      result.put(keyPrefix + "auto.offset.reset", autoOffsetReset);
      result.put(keyPrefix + "key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
      result.put(keyPrefix + "value.deserializer", valueDeserializer);

      return result;
    }
  }

  private static class _OutgoingEvent
  {
    private static final String _OUT_SUFFIX = "_OUT";
    private final String name;
    private final String topic;
    private final String valueSerializer;

    public _OutgoingEvent(String pName, String pTopic, String pValueSerializer)
    {
      name = pName;
      topic = pTopic;
      valueSerializer = pValueSerializer;
    }

    private _OutgoingEvent(Element pElement)
    {
      name = ElementFilter.fieldsIn(Collections.singletonList(pElement)).get(0).getConstantValue().toString();
      if (!name.endsWith(_OUT_SUFFIX))
        throw new RuntimeException(name + " is not a valid OUTGOINGEVENT name");

      topic = name.substring(0, name.length() - _OUT_SUFFIX.length());
      OutgoingEvent ev = pElement.getAnnotation(OutgoingEvent.class);
      valueSerializer = _getClassName(ev::valueSerializer);
    }

    @NotNull
    private Map<String, String> toMap(@NotNull Map<String, String> pDefaultValues)
    {
      String keyPrefix = "mp.messaging.outgoing." + name.replace('.', '-') + ".";
      Map<String, String> result = new HashMap<>();

      // Add defaults
      pDefaultValues.forEach((pKey, pValue) -> result.put(keyPrefix + pKey, pValue));

      // Add all our values
      result.put(keyPrefix + "topic", topic);
      result.put(keyPrefix + "key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
      result.put(keyPrefix + "value.serializer", valueSerializer);
      result.put(keyPrefix + "acks", "1");

      return result;
    }
  }

  private static String _getClassName(Supplier<Class<?>> pSupplier)
  {
    try
    {
      return pSupplier.get().getName();
    }
    catch (MirroredTypeException ex)
    {
      return ex.getTypeMirror().toString();
    }
  }

}
